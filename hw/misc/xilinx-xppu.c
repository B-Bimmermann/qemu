/*
 * QEMU model of the XPPU xppu
 *
 * Copyright (c) 2014 Xilinx Inc.
 *
 * Autogenerated by xregqemu.py 2014-12-16.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "hw/sysbus.h"
#include "hw/register.h"
#include "qemu/bitops.h"
#include "qemu/log.h"
#include "sysemu/dma.h"

#ifndef XILINX_XPPU_ERR_DEBUG
#define XILINX_XPPU_ERR_DEBUG 0
#endif

#define TYPE_XILINX_XPPU "xlnx.xppu"

#define XILINX_XPPU(obj) \
     OBJECT_CHECK(XPPU, (obj), TYPE_XILINX_XPPU)

REG32(CTRL, 0x0)
    FIELD(CTRL, APER_PARITY_EN, 1, 2)
    FIELD(CTRL, MID_PARITY_EN, 1, 1)
    FIELD(CTRL, ENABLE, 1, 0)
REG32(ERR_STATUS1, 0x4)
REG32(ERR_STATUS2, 0x8)
    FIELD(ERR_STATUS2, AXI_ID, 16, 0)
REG32(POISON, 0xc)
    FIELD(POISON, BASE, 20, 0)
REG32(ISR, 0x10)
    FIELD(ISR, APER_PARITY, 1, 7)
    FIELD(ISR, APER_TZ, 1, 6)
    FIELD(ISR, APER_PERM, 1, 5)
    FIELD(ISR, MID_PARITY, 1, 3)
    FIELD(ISR, MID_RO, 1, 2)
    FIELD(ISR, MID_MISS, 1, 1)
    FIELD(ISR, INV_APB, 1, 0)
REG32(IMR, 0x14)
    FIELD(IMR, APER_PARITY, 1, 7)
    FIELD(IMR, APER_TZ, 1, 6)
    FIELD(IMR, APER_PERM, 1, 5)
    FIELD(IMR, MID_PARITY, 1, 3)
    FIELD(IMR, MID_RO, 1, 2)
    FIELD(IMR, MID_MISS, 1, 1)
    FIELD(IMR, INV_APB, 1, 0)
REG32(IEN, 0x18)
    FIELD(IEN, APER_PARITY, 1, 7)
    FIELD(IEN, APER_TZ, 1, 6)
    FIELD(IEN, APER_PERM, 1, 5)
    FIELD(IEN, MID_PARITY, 1, 3)
    FIELD(IEN, MID_RO, 1, 2)
    FIELD(IEN, MID_MISS, 1, 1)
    FIELD(IEN, INV_APB, 1, 0)
REG32(IDS, 0x1c)
    FIELD(IDS, APER_PARITY, 1, 7)
    FIELD(IDS, APER_TZ, 1, 6)
    FIELD(IDS, APER_PERM, 1, 5)
    FIELD(IDS, MID_PARITY, 1, 3)
    FIELD(IDS, MID_RO, 1, 2)
    FIELD(IDS, MID_MISS, 1, 1)
    FIELD(IDS, INV_APB, 1, 0)
REG32(M_MASTER_IDS, 0x3c)
REG32(M_APERTURE_32B, 0x40)
REG32(M_APERTURE_64KB, 0x44)
REG32(M_APERTURE_1MB, 0x48)
REG32(M_APERTURE_512MB, 0x4c)
REG32(BASE_32B, 0x50)
REG32(BASE_64KB, 0x54)
REG32(BASE_1MB, 0x58)
REG32(BASE_512MB, 0x5c)
REG32(ECO, 0xfc)
REG32(MASTER_ID, 0x100)
    FIELD(MASTER_ID, MIDP, 1, 31)
    FIELD(MASTER_ID, MIDR, 1, 30)
    FIELD(MASTER_ID, MIDM, 10, 16)
    FIELD(MASTER_ID, MID, 10, 0)
REG32(RAM_ADJ, 0x1fc)
    FIELD(RAM_ADJ, MESSAGE_EMAS, 1, 13)
    FIELD(RAM_ADJ, MESSAGE_EMAW, 2, 11)
    FIELD(RAM_ADJ, MESSAGE_EMA, 3, 8)
    FIELD(RAM_ADJ, PERMISSION_EMAS, 1, 5)
    FIELD(RAM_ADJ, PERMISSION_EMAW, 2, 3)
    FIELD(RAM_ADJ, PERMISSION_EMA, 3, 0)

#define NUM_MID_MATCHERS 20

#define R_MAX (R_RAM_ADJ + 1)

#define A_APL       0x1000
#define APL_SIZE    0x1000

#define NUM_XPPU_REGIONS 4

#define XPPU_MID_PARITY_BITS 0xc3ff03ff

typedef struct XPPU XPPU;

typedef struct XPPURegion {
    XPPU *parent;

    MemoryRegion mr;
    uint32_t stride;
    uint32_t entries;
    uint32_t offset;
    uint32_t apl_offset;
} XPPURegion;

struct XPPU {
    SysBusDevice parent_obj;
    MemoryRegion iomem;
    qemu_irq irq_isr;

    MemoryRegion *master_mr;
    AddressSpace *master_as;

    XPPURegion regions[NUM_XPPU_REGIONS];

    uint32_t apl[APL_SIZE /4];

    uint32_t regs[R_MAX];
    RegisterInfo regs_info[R_MAX];
};

static void isr_update_irq(XPPU *s)
{
    bool pending = s->regs[R_ISR] & ~s->regs[R_IMR];
    qemu_set_irq(s->irq_isr, pending);
}

static void isr_postw(RegisterInfo *reg, uint64_t val64)
{
    XPPU *s = XILINX_XPPU(reg->opaque);
    isr_update_irq(s);
}

static uint64_t ien_prew(RegisterInfo *reg, uint64_t val64)
{
    XPPU *s = XILINX_XPPU(reg->opaque);
    uint32_t val = val64;

    s->regs[R_IMR] &= ~val;
    isr_update_irq(s);
    return 0;
}

static uint64_t ids_prew(RegisterInfo *reg, uint64_t val64)
{
    XPPU *s = XILINX_XPPU(reg->opaque);
    uint32_t val = val64;

    s->regs[R_IMR] |= val;
    isr_update_irq(s);
    return 0;
}

static RegisterAccessInfo xppu_regs_info[] = {
    {   .name = "CTRL",  .decode.addr = A_CTRL,
        .rsvd = 0xfffffff8,
        .ro = 0xfffffff8,
    },{ .name = "ERR_STATUS1",  .decode.addr = A_ERR_STATUS1,
        .ro = 0xffffffff,
    },{ .name = "ERR_STATUS2",  .decode.addr = A_ERR_STATUS2,
        .rsvd = 0xffff0000,
        .ro = 0xffffffff,
    },{ .name = "POISON",  .decode.addr = A_POISON,
        .rsvd = 0xfff00000,
        .ro = 0xffffffff,
    },{ .name = "ISR",  .decode.addr = A_ISR,
        .rsvd = 0xffffff10,
        .ro = 0xffffff10,
        .w1c = 0xef,
        .post_write = isr_postw,
    },{ .name = "IMR",  .decode.addr = A_IMR,
        .reset = 0xef,
        .rsvd = 0xffffff10,
        .ro = 0xffffffff,
    },{ .name = "IEN",  .decode.addr = A_IEN,
        .rsvd = 0xffffff10,
        .ro = 0xffffff10,
        .pre_write = ien_prew,
    },{ .name = "IDS",  .decode.addr = A_IDS,
        .rsvd = 0xffffff10,
        .ro = 0xffffff10,
        .pre_write = ids_prew,
    },{ .name = "M_MASTER_IDS",  .decode.addr = A_M_MASTER_IDS,
        .reset = 0x14,
        .ro = 0xffffffff,
    },{ .name = "M_APERTURE_32B",  .decode.addr = A_M_APERTURE_32B,
        .reset = 0x80,
        .ro = 0xffffffff,
    },{ .name = "M_APERTURE_64KB",  .decode.addr = A_M_APERTURE_64KB,
        .reset = 0x100,
        .ro = 0xffffffff,
    },{ .name = "M_APERTURE_1MB",  .decode.addr = A_M_APERTURE_1MB,
        .reset = 0x10,
        .ro = 0xffffffff,
    },{ .name = "M_APERTURE_512MB",  .decode.addr = A_M_APERTURE_512MB,
        .reset = 0x1,
        .ro = 0xffffffff,
    },{ .name = "BASE_32B",  .decode.addr = A_BASE_32B,
        .ro = 0xffffffff,
    },{ .name = "BASE_64KB",  .decode.addr = A_BASE_64KB,
        .ro = 0xffffffff,
    },{ .name = "BASE_1MB",  .decode.addr = A_BASE_1MB,
        .ro = 0xffffffff,
    },{ .name = "BASE_512MB",  .decode.addr = A_BASE_512MB,
        .ro = 0xffffffff,
    },{ .name = "ECO",  .decode.addr = A_ECO,
    },

#define MASTER_IDn(n) \
    {   .name = "MASTER_ID" #n,  .decode.addr = A_MASTER_ID + 4 * n,           \
        .reset = 0x83ff0040,                                                   \
        .rsvd = 0x3c00fc00,                                                    \
        .ro = 0x3c00fc00,                                                      \
    }
    MASTER_IDn( 0), MASTER_IDn( 1), MASTER_IDn( 2), MASTER_IDn( 3),
    MASTER_IDn( 4), MASTER_IDn( 5), MASTER_IDn( 6), MASTER_IDn( 7),
    MASTER_IDn( 8), MASTER_IDn( 9), MASTER_IDn(10), MASTER_IDn(11),
    MASTER_IDn(12), MASTER_IDn(13), MASTER_IDn(14), MASTER_IDn(15),
    MASTER_IDn(16), MASTER_IDn(17), MASTER_IDn(18), MASTER_IDn(19),

    { .name = "RAM_ADJ",  .decode.addr = A_RAM_ADJ,
        .reset = 0xa0a,
        .rsvd = 0xffffc0c0,
        .ro = 0xffffc0c0,
    }
};

static void xppu_reset(DeviceState *dev)
{
    XPPU *s = XILINX_XPPU(dev);
    unsigned int i;

    for (i = 0; i < ARRAY_SIZE(s->regs_info); ++i) {
        register_reset(&s->regs_info[i]);
    }

    isr_update_irq(s);
}

static uint64_t xppu_read(void *opaque, hwaddr addr, unsigned size)
{
    XPPU *s = XILINX_XPPU(opaque);
    RegisterInfo *r = &s->regs_info[addr / 4];

    if (addr >= A_APL) {
        return s->apl[(addr - A_APL) / 4];
    }

    if (!r->data) {
        qemu_log("%s: Decode error: read from %" HWADDR_PRIx "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr);
        return 0;
    }
    return register_read(r);
}

static void xppu_write(void *opaque, hwaddr addr, uint64_t value,
                      unsigned size)
{
    XPPU *s = XILINX_XPPU(opaque);
    RegisterInfo *r = &s->regs_info[addr / 4];

    if (addr >= A_APL) {
        s->apl[(addr - A_APL) / 4] = value;
        return;
    }

    if (!r->data) {
        qemu_log("%s: Decode error: write to %" HWADDR_PRIx "=%" PRIx64 "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr, value);
        return;
    }
    register_write(r, value, ~0);
}

static const MemoryRegionOps xppu_ops = {
    .read = xppu_read,
    .write = xppu_write,
    .endianness = DEVICE_LITTLE_ENDIAN,
    .valid = {
        .min_access_size = 4,
        .max_access_size = 4,
    },
};

static inline bool parity32(uint32_t val)
{
    int ret = 0;

    for (; val; val >>= 1) {
        ret ^= val & 0x1;
    }
    return ret;
}

static const uint32_t xppu_apl_parity_checks [] = {
    0x880f8000,
    0x40007c00,
    0x200003e0,
    0x1000001f
};

static inline bool xppu_apl_parity_check(uint32_t val)
{
    int i;

    for (i = 0; i < ARRAY_SIZE(xppu_apl_parity_checks); ++i) {

        if (parity32(val & xppu_apl_parity_checks[i])) {
            return true;
        }
    }
    return false;
}

static inline uint64_t xppu_mr_rw(void *opaque, hwaddr addr, uint64_t value,
                                  unsigned size, bool rnw,
                                  MemoryTransactionAttr *attr)
{
    XPPURegion *r = opaque;
    XPPU *s = r->parent;
    DMADirection dir = rnw ? DMA_DIRECTION_TO_DEVICE :
                             DMA_DIRECTION_FROM_DEVICE;
    value = cpu_to_le64(value);
    uint32_t apl_entry, apl_value;
    int i;

    /*fprintf(stderr, "%s %" HWADDR_PRIx " %" PRIx32 " %" PRIx64 "\n",
            __func__, addr, r->offset, value);*/

    if (!AF_EX32(s->regs, CTRL, ENABLE)) {
        /*bypass*/
        goto txn_ok;
    }

    apl_entry = addr / r->stride;
    assert(apl_entry < r->entries);
    apl_value = s->apl[r->apl_offset / 4  + apl_entry];

    if (xppu_apl_parity_check(apl_value)) {
        /* FIXME: Raise APL parity interrupt here */
        goto txn_not_ok;
    }

    for (i = 0; i < NUM_MID_MATCHERS; ++i) {
        uint32_t mid_match;

        if (!(apl_value & (1 << i))) {
            continue;
        }
        mid_match = s->regs[R_MASTER_ID + i];
        if (!rnw && F_EX32(mid_match, MASTER_ID, MIDR)) {
            /* read only on a write */
            continue;
        }
        if (parity32(mid_match & XPPU_MID_PARITY_BITS)) {
            /* Parity busted MID matcher */
            continue;
        }
        /* QEMU doesn't model MIDs yet. So assume all MIDs are ok. All we are
         * checking is the RO bit and whether this is an entry enabled really
         */
        goto txn_ok;
    }

txn_not_ok:

    /* transaction not ok */
    qemu_log_mask(LOG_GUEST_ERROR, "XPPU blocked transaction to %"
                  HWADDR_PRIx "\n", addr + r->offset);

    return 0;

txn_ok:
    dma_memory_rw_attr(s->master_as, addr + r->offset, &value, size, dir, attr);

    return le64_to_cpu(value);
}

static uint64_t xppu_mr_read(void *opaque, hwaddr addr, unsigned size)
{
    return xppu_mr_rw(opaque, addr, 0, size, true, NULL);
}

static void xppu_mr_write(void *opaque, hwaddr addr, uint64_t value,
                          unsigned size)
{
    xppu_mr_rw(opaque, addr, value, size, false, NULL);
}

static void xppu_mr_access(MemoryTransaction *tr)
{
    MemoryTransactionAttr *attr = tr->attr;
    void *opaque = tr->opaque;
    hwaddr addr = tr->addr;
    unsigned size = tr->size;
    uint64_t value = tr->data.u64;;
    bool is_write = tr->rw;

    tr->data.u64 = xppu_mr_rw(opaque, addr, value, size, !is_write, attr);
}

static const MemoryRegionOps xppu_mr_ops = {
    .read = xppu_mr_read,
    .write = xppu_mr_write,
    .access = xppu_mr_access,
    .endianness = DEVICE_LITTLE_ENDIAN,
    .valid = {
        .min_access_size = 4,
        .max_access_size = 4,
    },
};


static void xppu_realize(DeviceState *dev, Error **errp)
{
    XPPU *s = XILINX_XPPU(dev);
    const char *prefix = object_get_canonical_path(OBJECT(dev));
    unsigned int i;

    for (i = 0; i < ARRAY_SIZE(xppu_regs_info); ++i) {
        RegisterInfo *r = &s->regs_info[xppu_regs_info[i].decode.addr/4];

        *r = (RegisterInfo) {
            .data = (uint8_t *)&s->regs[
                    xppu_regs_info[i].decode.addr/4],
            .data_size = sizeof(uint32_t),
            .access = &xppu_regs_info[i],
            .debug = XILINX_XPPU_ERR_DEBUG,
            .prefix = prefix,
            .opaque = s,
        };
    }

    s->master_as = s->master_mr ?
                   address_space_init_shareable(s->master_mr, NULL) :
                   &address_space_memory;

    for (i = 0; i < NUM_XPPU_REGIONS; ++i) {
        XPPURegion *r = &s->regions[i];

        object_property_set_int(OBJECT(&r->mr), r->stride * r->entries,
                                "size", &error_abort);
    }
}

static void xppu_init(Object *obj)
{
    XPPU *s = XILINX_XPPU(obj);
    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);
    int i;

    memory_region_init_io(&s->iomem, obj, &xppu_ops, s,
                          TYPE_XILINX_XPPU, A_APL + APL_SIZE);
    sysbus_init_mmio(sbd, &s->iomem);
    sysbus_init_irq(sbd, &s->irq_isr);

    for (i = 0; i < NUM_XPPU_REGIONS; ++i) {
        XPPURegion *r = &s->regions[i];

        r->parent = s;
        memory_region_init_io(&r->mr, obj, &xppu_mr_ops, r,
                              "xppu region", 0);
        sysbus_init_mmio(sbd, &r->mr);
    }

    object_property_add_link(obj, "master", TYPE_MEMORY_REGION,
                             (Object **)&s->master_mr,
                             qdev_prop_allow_set_link_before_realize,
                             OBJ_PROP_LINK_UNREF_ON_RELEASE,
                             &error_abort);
}

static const VMStateDescription vmstate_xppu = {
    .name = TYPE_XILINX_XPPU,
    .version_id = 1,
    .minimum_version_id = 1,
    .minimum_version_id_old = 1,
    .fields = (VMStateField[]) {
        VMSTATE_UINT32_ARRAY(regs, XPPU, R_MAX),
        VMSTATE_END_OF_LIST(),
    }
};

static Property xppu_properties[] = {
    DEFINE_PROP_UINT32("stride-0", XPPU, regions[0].stride,         64 << 10),
    DEFINE_PROP_UINT32("entries-0", XPPU, regions[0].entries,       256),
    DEFINE_PROP_UINT32("offset-0", XPPU, regions[0].offset,         0xFF000000),
    DEFINE_PROP_UINT32("apl-offset-0", XPPU, regions[0].apl_offset, 0x0),
    DEFINE_PROP_UINT32("stride-1", XPPU, regions[1].stride,         32),
    DEFINE_PROP_UINT32("entries-1", XPPU, regions[1].entries,       128),
    /* FIXME: Wrong */
    DEFINE_PROP_UINT32("offset-1", XPPU, regions[1].offset,         0x80000000),
    DEFINE_PROP_UINT32("apl-offset-1", XPPU, regions[1].apl_offset, 0x400),
    DEFINE_PROP_UINT32("stride-2", XPPU, regions[2].stride,         1 << 20),
    DEFINE_PROP_UINT32("entries-2", XPPU, regions[2].entries,       16),
    DEFINE_PROP_UINT32("offset-2", XPPU, regions[2].offset,         0xFE000000),
    DEFINE_PROP_UINT32("apl-offset-2", XPPU, regions[2].apl_offset, 0x600),
    DEFINE_PROP_UINT32("stride-3", XPPU, regions[3].stride,         512 << 20),
    DEFINE_PROP_UINT32("entries-3", XPPU, regions[3].entries,       1),
    DEFINE_PROP_UINT32("offset-3", XPPU, regions[3].offset,         0xC0000000),
    DEFINE_PROP_UINT32("apl-offset-3", XPPU, regions[3].apl_offset, 0x640),
    DEFINE_PROP_END_OF_LIST(),
};

static void xppu_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    dc->reset = xppu_reset;
    dc->realize = xppu_realize;
    dc->vmsd = &vmstate_xppu;
    dc->props = xppu_properties;
}

static const TypeInfo xppu_info = {
    .name          = TYPE_XILINX_XPPU,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(XPPU),
    .class_init    = xppu_class_init,
    .instance_init = xppu_init,
};

static void xppu_register_types(void)
{
    type_register_static(&xppu_info);
}

type_init(xppu_register_types)
