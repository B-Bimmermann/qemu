/*
 * QEMU model of the CRL_APB APB control registers for clock controller. The rstctrl_lpd willbe added to this as well
 *
 * Copyright (c) 2014 Xilinx Inc.
 *
 * Autogenerated by xregqemu.py 2014-03-20.
 * Written by Edgar E. Iglesias
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "hw/sysbus.h"
#include "hw/register.h"
#include "qemu/bitops.h"
#include "qemu/log.h"

#include "sysemu/sysemu.h"

#include "hw/fdt_generic_util.h"

#ifndef XILINX_CRL_APB_ERR_DEBUG
#define XILINX_CRL_APB_ERR_DEBUG 0
#endif

#define TYPE_XILINX_CRL_APB "xlnx.ronaldo-crl"

#define XILINX_CRL_APB(obj) \
     OBJECT_CHECK(CRL_APB, (obj), TYPE_XILINX_CRL_APB)

REG32(ERR_CTRL, 0x0)
    FIELD(ERR_CTRL, SLVERR_ENABLE, 1, 0)
REG32(IR_STATUS, 0x4)
    FIELD(IR_STATUS, ADDR_DECODE_ERR, 1, 0)
REG32(IR_MASK, 0x8)
    FIELD(IR_MASK, ADDR_DECODE_ERR, 1, 0)
REG32(IR_ENABLE, 0xc)
    FIELD(IR_ENABLE, ADDR_DECODE_ERR, 1, 0)
REG32(IR_DISABLE, 0x10)
    FIELD(IR_DISABLE, ADDR_DECODE_ERR, 1, 0)
REG32(CRL_ECO, 0x18)
REG32(IOPLL_CTRL, 0x20)
    FIELD(IOPLL_CTRL, POST_SRC, 3, 24)
    FIELD(IOPLL_CTRL, PRE_SRC, 3, 20)
    FIELD(IOPLL_CTRL, CLKOUTDIV, 1, 17)
    FIELD(IOPLL_CTRL, DIV2, 1, 16)
    FIELD(IOPLL_CTRL, FBDIV, 7, 8)
    FIELD(IOPLL_CTRL, BYPASS, 1, 3)
    FIELD(IOPLL_CTRL, RESET, 1, 0)
REG32(IOPLL_CFG, 0x24)
    FIELD(IOPLL_CFG, LOCK_DLY, 7, 25)
    FIELD(IOPLL_CFG, LOCK_CNT, 10, 13)
    FIELD(IOPLL_CFG, LFHF, 2, 10)
    FIELD(IOPLL_CFG, CP, 4, 5)
    FIELD(IOPLL_CFG, RES, 4, 0)
REG32(IOPLL_FRAC_CFG, 0x28)
    FIELD(IOPLL_FRAC_CFG, ENABLED, 1, 31)
    FIELD(IOPLL_FRAC_CFG, SEED, 3, 22)
    FIELD(IOPLL_FRAC_CFG, ALGRTHM, 1, 19)
    FIELD(IOPLL_FRAC_CFG, ORDER, 1, 18)
    FIELD(IOPLL_FRAC_CFG, DATA, 16, 0)
REG32(RPLL_CTRL, 0x30)
    FIELD(RPLL_CTRL, POST_SRC, 3, 24)
    FIELD(RPLL_CTRL, PRE_SRC, 3, 20)
    FIELD(RPLL_CTRL, CLKOUTDIV, 1, 17)
    FIELD(RPLL_CTRL, DIV2, 1, 16)
    FIELD(RPLL_CTRL, FBDIV, 7, 8)
    FIELD(RPLL_CTRL, BYPASS, 1, 3)
    FIELD(RPLL_CTRL, RESET, 1, 0)
REG32(RPLL_CFG, 0x34)
    FIELD(RPLL_CFG, LOCK_DLY, 7, 25)
    FIELD(RPLL_CFG, LOCK_CNT, 10, 13)
    FIELD(RPLL_CFG, LFHF, 2, 10)
    FIELD(RPLL_CFG, CP, 4, 5)
    FIELD(RPLL_CFG, RES, 4, 0)
REG32(RPLL_FRAC_CFG, 0x38)
    FIELD(RPLL_FRAC_CFG, ENABLED, 1, 31)
    FIELD(RPLL_FRAC_CFG, SEED, 3, 22)
    FIELD(RPLL_FRAC_CFG, ALGRTHM, 1, 19)
    FIELD(RPLL_FRAC_CFG, ORDER, 1, 18)
    FIELD(RPLL_FRAC_CFG, DATA, 16, 0)
REG32(PLL_STATUS, 0x40)
    FIELD(PLL_STATUS, RPLL_STABLE, 1, 4)
    FIELD(PLL_STATUS, IOPLL_STABLE, 1, 3)
    FIELD(PLL_STATUS, RPLL_LOCK, 1, 1)
    FIELD(PLL_STATUS, IOPLL_LOCK, 1, 0)
REG32(IOPLL_TO_FPD_CTRL, 0x44)
    FIELD(IOPLL_TO_FPD_CTRL, DIVISOR0, 6, 8)
REG32(RPLL_TO_FPD_CTRL, 0x48)
    FIELD(RPLL_TO_FPD_CTRL, DIVISOR0, 6, 8)
REG32(USB3_DUAL_REF_CTRL, 0x4c)
    FIELD(USB3_DUAL_REF_CTRL, CLKACT, 1, 25)
    FIELD(USB3_DUAL_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(USB3_DUAL_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(USB3_DUAL_REF_CTRL, SRCSEL, 3, 0)
REG32(GEM0_REF_CTRL, 0x50)
    FIELD(GEM0_REF_CTRL, RX_CLKACT, 1, 26)
    FIELD(GEM0_REF_CTRL, CLKACT, 1, 25)
    FIELD(GEM0_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(GEM0_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(GEM0_REF_CTRL, SRCSEL, 3, 0)
REG32(GEM1_REF_CTRL, 0x54)
    FIELD(GEM1_REF_CTRL, RX_CLKACT, 1, 26)
    FIELD(GEM1_REF_CTRL, CLKACT, 1, 25)
    FIELD(GEM1_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(GEM1_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(GEM1_REF_CTRL, SRCSEL, 3, 0)
REG32(GEM2_REF_CTRL, 0x58)
    FIELD(GEM2_REF_CTRL, RX_CLKACT, 1, 26)
    FIELD(GEM2_REF_CTRL, CLKACT, 1, 25)
    FIELD(GEM2_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(GEM2_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(GEM2_REF_CTRL, SRCSEL, 3, 0)
REG32(GEM3_REF_CTRL, 0x5c)
    FIELD(GEM3_REF_CTRL, RX_CLKACT, 1, 26)
    FIELD(GEM3_REF_CTRL, CLKACT, 1, 25)
    FIELD(GEM3_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(GEM3_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(GEM3_REF_CTRL, SRCSEL, 3, 0)
REG32(USB0_BUS_REF_CTRL, 0x60)
    FIELD(USB0_BUS_REF_CTRL, CLKACT, 1, 25)
    FIELD(USB0_BUS_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(USB0_BUS_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(USB0_BUS_REF_CTRL, SRCSEL, 3, 0)
REG32(USB1_BUS_REF_CTRL, 0x64)
    FIELD(USB1_BUS_REF_CTRL, CLKACT, 1, 25)
    FIELD(USB1_BUS_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(USB1_BUS_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(USB1_BUS_REF_CTRL, SRCSEL, 3, 0)
REG32(QSPI_REF_CTRL, 0x68)
    FIELD(QSPI_REF_CTRL, CLKACT, 1, 24)
    FIELD(QSPI_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(QSPI_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(QSPI_REF_CTRL, SRCSEL, 3, 0)
REG32(SDIO0_REF_CTRL, 0x6c)
    FIELD(SDIO0_REF_CTRL, CLKACT, 1, 24)
    FIELD(SDIO0_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(SDIO0_REF_CTRL, SRCSEL, 3, 0)
REG32(SDIO1_REF_CTRL, 0x70)
    FIELD(SDIO1_REF_CTRL, CLKACT, 1, 24)
    FIELD(SDIO1_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(SDIO1_REF_CTRL, SRCSEL, 3, 0)
REG32(UART0_REF_CTRL, 0x74)
    FIELD(UART0_REF_CTRL, CLKACT, 1, 24)
    FIELD(UART0_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(UART0_REF_CTRL, SRCSEL, 3, 0)
REG32(UART1_REF_CTRL, 0x78)
    FIELD(UART1_REF_CTRL, CLKACT, 1, 24)
    FIELD(UART1_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(UART1_REF_CTRL, SRCSEL, 3, 0)
REG32(SPI0_REF_CTRL, 0x7c)
    FIELD(SPI0_REF_CTRL, CLKACT, 1, 24)
    FIELD(SPI0_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(SPI0_REF_CTRL, SRCSEL, 3, 0)
REG32(SPI1_REF_CTRL, 0x80)
    FIELD(SPI1_REF_CTRL, CLKACT, 1, 24)
    FIELD(SPI1_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(SPI1_REF_CTRL, SRCSEL, 3, 0)
REG32(CAN0_REF_CTRL, 0x84)
    FIELD(CAN0_REF_CTRL, CLKACT, 1, 24)
    FIELD(CAN0_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(CAN0_REF_CTRL, SRCSEL, 3, 0)
REG32(CAN1_REF_CTRL, 0x88)
    FIELD(CAN1_REF_CTRL, CLKACT, 1, 24)
    FIELD(CAN1_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(CAN1_REF_CTRL, SRCSEL, 3, 0)
REG32(DBG_R5_ATCLK_CTRL, 0x8c)
    FIELD(DBG_R5_ATCLK_CTRL, CLKACT, 1, 24)
    FIELD(DBG_R5_ATCLK_CTRL, DIVISOR0, 6, 8)
    FIELD(DBG_R5_ATCLK_CTRL, SRCSEL, 3, 0)
REG32(CPU_R5_CTRL, 0x90)
    FIELD(CPU_R5_CTRL, CLKACT, 1, 24)
    FIELD(CPU_R5_CTRL, DIVISOR0, 6, 8)
    FIELD(CPU_R5_CTRL, SRCSEL, 3, 0)
REG32(OCM_MAIN_CTRL, 0x94)
    FIELD(OCM_MAIN_CTRL, CLKACT, 1, 24)
    FIELD(OCM_MAIN_CTRL, DIVISOR0, 6, 8)
    FIELD(OCM_MAIN_CTRL, SRCSEL, 3, 0)
REG32(IOU_SWITCH_CTRL, 0x9c)
    FIELD(IOU_SWITCH_CTRL, CLKACT, 1, 24)
    FIELD(IOU_SWITCH_CTRL, DIVISOR0, 6, 8)
    FIELD(IOU_SWITCH_CTRL, SRCSEL, 3, 0)
REG32(CSU_PLL_CTRL, 0xa0)
    FIELD(CSU_PLL_CTRL, CLKACT, 1, 24)
    FIELD(CSU_PLL_CTRL, DIVISOR0, 6, 8)
    FIELD(CSU_PLL_CTRL, SRCSEL, 3, 0)
REG32(PCAP_CTRL, 0xa4)
    FIELD(PCAP_CTRL, CLKACT, 1, 24)
    FIELD(PCAP_CTRL, DIVISOR0, 6, 8)
    FIELD(PCAP_CTRL, SRCSEL, 3, 0)
REG32(LPD_SWITCH_CTRL, 0xa8)
    FIELD(LPD_SWITCH_CTRL, CLKACT, 1, 24)
    FIELD(LPD_SWITCH_CTRL, DIVISOR0, 6, 8)
    FIELD(LPD_SWITCH_CTRL, SRCSEL, 3, 0)
REG32(LPD_LSBUS_CTRL, 0xac)
    FIELD(LPD_LSBUS_CTRL, CLKACT, 1, 24)
    FIELD(LPD_LSBUS_CTRL, DIVISOR0, 6, 8)
    FIELD(LPD_LSBUS_CTRL, SRCSEL, 3, 0)
REG32(DBG_LPD_CTRL, 0xb0)
    FIELD(DBG_LPD_CTRL, CLKACT, 1, 24)
    FIELD(DBG_LPD_CTRL, DIVISOR0, 6, 8)
    FIELD(DBG_LPD_CTRL, SRCSEL, 3, 0)
REG32(NAND_REF_CTRL, 0xb4)
    FIELD(NAND_REF_CTRL, CLKACT, 1, 24)
    FIELD(NAND_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(NAND_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(NAND_REF_CTRL, SRCSEL, 3, 0)
REG32(ADMA_REF_CTRL, 0xb8)
    FIELD(ADMA_REF_CTRL, CLKACT, 1, 24)
    FIELD(ADMA_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(ADMA_REF_CTRL, SRCSEL, 3, 0)
REG32(PL0_REF_CTRL, 0xc0)
    FIELD(PL0_REF_CTRL, CLKACT, 1, 24)
    FIELD(PL0_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(PL0_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(PL0_REF_CTRL, SRCSEL, 3, 0)
REG32(PL1_REF_CTRL, 0xc4)
    FIELD(PL1_REF_CTRL, CLKACT, 1, 24)
    FIELD(PL1_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(PL1_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(PL1_REF_CTRL, SRCSEL, 3, 0)
REG32(PL2_REF_CTRL, 0xc8)
    FIELD(PL2_REF_CTRL, CLKACT, 1, 24)
    FIELD(PL2_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(PL2_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(PL2_REF_CTRL, SRCSEL, 3, 0)
REG32(PL3_REF_CTRL, 0xcc)
    FIELD(PL3_REF_CTRL, CLKACT, 1, 24)
    FIELD(PL3_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(PL3_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(PL3_REF_CTRL, SRCSEL, 3, 0)
REG32(PL0_THR_CTRL, 0xd0)
    FIELD(PL0_THR_CTRL, CURR_VAL, 16, 16)
    FIELD(PL0_THR_CTRL, RUNNING, 1, 15)
    FIELD(PL0_THR_CTRL, CPU_START, 1, 1)
    FIELD(PL0_THR_CTRL, CNT_RST, 1, 0)
REG32(PL0_THR_CNT, 0xd4)
    FIELD(PL0_THR_CNT, LAST_CNT, 16, 0)
REG32(PL1_THR_CTRL, 0xd8)
    FIELD(PL1_THR_CTRL, CURR_VAL, 16, 16)
    FIELD(PL1_THR_CTRL, RUNNING, 1, 15)
    FIELD(PL1_THR_CTRL, CPU_START, 1, 1)
    FIELD(PL1_THR_CTRL, CNT_RST, 1, 0)
REG32(PL1_THR_CNT, 0xdc)
    FIELD(PL1_THR_CNT, LAST_CNT, 16, 0)
REG32(PL2_THR_CTRL, 0xe0)
    FIELD(PL2_THR_CTRL, CURR_VAL, 16, 16)
    FIELD(PL2_THR_CTRL, RUNNING, 1, 15)
    FIELD(PL2_THR_CTRL, CPU_START, 1, 1)
    FIELD(PL2_THR_CTRL, CNT_RST, 1, 0)
REG32(PL2_THR_CNT, 0xe4)
    FIELD(PL2_THR_CNT, LAST_CNT, 16, 0)
REG32(PL3_THR_CTRL, 0xe8)
    FIELD(PL3_THR_CTRL, CURR_VAL, 16, 16)
    FIELD(PL3_THR_CTRL, RUNNING, 1, 15)
    FIELD(PL3_THR_CTRL, CPU_START, 1, 1)
    FIELD(PL3_THR_CTRL, CNT_RST, 1, 0)
REG32(PL3_THR_CNT, 0xfc)
    FIELD(PL3_THR_CNT, LAST_CNT, 16, 0)
REG32(GEM_TSU_REF_CTRL, 0x100)
    FIELD(GEM_TSU_REF_CTRL, CLKACT, 1, 24)
    FIELD(GEM_TSU_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(GEM_TSU_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(GEM_TSU_REF_CTRL, SRCSEL, 3, 0)
REG32(DLL_REF_CTRL, 0x104)
    FIELD(DLL_REF_CTRL, SRCSEL, 3, 0)
REG32(AMS_REF_CTRL, 0x108)
    FIELD(AMS_REF_CTRL, CLKACT, 1, 24)
    FIELD(AMS_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(AMS_REF_CTRL, SRCSEL, 3, 0)
REG32(I2C0_REF_CTRL, 0x120)
    FIELD(I2C0_REF_CTRL, CLKACT, 1, 24)
    FIELD(I2C0_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(I2C0_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(I2C0_REF_CTRL, SRCSEL, 3, 0)
REG32(I2C1_REF_CTRL, 0x124)
    FIELD(I2C1_REF_CTRL, CLKACT, 1, 24)
    FIELD(I2C1_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(I2C1_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(I2C1_REF_CTRL, SRCSEL, 3, 0)
REG32(TIMESTAMP_REF_CTRL, 0x128)
    FIELD(TIMESTAMP_REF_CTRL, CLKACT, 1, 24)
    FIELD(TIMESTAMP_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(TIMESTAMP_REF_CTRL, SRCSEL, 3, 0)
REG32(PICDEBUG_TEMP_CTRL, 0x150)
    FIELD(PICDEBUG_TEMP_CTRL, SRCSEL, 3, 0)
REG32(PICDEBUG_REF_CTRL, 0x154)
    FIELD(PICDEBUG_REF_CTRL, CLKACT, 1, 24)
    FIELD(PICDEBUG_REF_CTRL, DIVISOR1, 6, 16)
    FIELD(PICDEBUG_REF_CTRL, DIVISOR0, 6, 8)
    FIELD(PICDEBUG_REF_CTRL, SRCSEL, 3, 0)
REG32(PICDEBUG_CTRL, 0x158)
    FIELD(PICDEBUG_CTRL, START, 1, 4)
    FIELD(PICDEBUG_CTRL, TRIGGER_SEL, 2, 2)
    FIELD(PICDEBUG_CTRL, CNT_LOAD, 1, 1)
    FIELD(PICDEBUG_CTRL, TRIGGER_EN, 1, 0)
REG32(PICDEBUG_LCNT, 0x15c)
REG32(PICDEBUG_UCNT, 0x160)
    FIELD(PICDEBUG_UCNT, VALUE, 16, 0)

REG32(BOOT_MODE, 0x200)
    FIELD(BOOT_MODE, BOOT_MODE, 4, 0)
REG32(BOOT_MODE_RAW, 0x204)
    FIELD(BOOT_MODE_RAW, BOOT_MODE2, 4, 8)
    FIELD(BOOT_MODE_RAW, BOOT_MODE1, 4, 4)
    FIELD(BOOT_MODE_RAW, BOOT_MODE0, 4, 0)
REG32(EN_POR_RST, 0x210)
    FIELD(EN_POR_RST, DEBUG_SYS, 1, 8)
    FIELD(EN_POR_RST, SOFT, 1, 7)
    FIELD(EN_POR_RST, SRST, 1, 6)
    FIELD(EN_POR_RST, FPD_SWDT, 1, 5)
    FIELD(EN_POR_RST, LPD_SWDT, 1, 4)
    FIELD(EN_POR_RST, A9WDT1, 1, 1)
    FIELD(EN_POR_RST, A9WDT0, 1, 0)
REG32(MIMIC_RST, 0x214)
    FIELD(MIMIC_RST, DEBUG_ONLY, 1, 9)
    FIELD(MIMIC_RST, DEBUG_SYS, 1, 8)
    FIELD(MIMIC_RST, SOFT, 1, 7)
    FIELD(MIMIC_RST, SRST, 1, 6)
    FIELD(MIMIC_RST, FPD_SWDT, 1, 5)
    FIELD(MIMIC_RST, LPD_SWDT, 1, 4)
    FIELD(MIMIC_RST, A9WDT1, 1, 1)
    FIELD(MIMIC_RST, A9WDT0, 1, 0)
REG32(RESET_CTRL, 0x218)
    FIELD(RESET_CTRL, SRST_DIS, 1, 6)
    FIELD(RESET_CTRL, FPD_SWDT, 1, 5)
    FIELD(RESET_CTRL, LPD_SWDT, 1, 4)
    FIELD(RESET_CTRL, A9WDT1, 1, 1)
    FIELD(RESET_CTRL, A9WDT0, 1, 0)
REG32(BLOCKONLY_RST, 0x21c)
    FIELD(BLOCKONLY_RST, MIMIC, 1, 15)
    FIELD(BLOCKONLY_RST, DEBUG_ONLY, 1, 9)
    FIELD(BLOCKONLY_RST, FPD_SWDT, 1, 5)
    FIELD(BLOCKONLY_RST, LPD_SWDT, 1, 4)
    FIELD(BLOCKONLY_RST, A9WDT1, 1, 1)
    FIELD(BLOCKONLY_RST, A9WDT0, 1, 0)
REG32(RESET_REASON, 0x220)
    FIELD(RESET_REASON, MIMIC, 1, 15)
    FIELD(RESET_REASON, DEBUG_SYS, 1, 8)
    FIELD(RESET_REASON, SOFT, 1, 7)
    FIELD(RESET_REASON, SRST, 1, 6)
    FIELD(RESET_REASON, FPD_SWDT, 1, 5)
    FIELD(RESET_REASON, LPD_SWDT, 1, 4)
    FIELD(RESET_REASON, A9WDT1, 1, 1)
    FIELD(RESET_REASON, A9WDT0, 1, 0)
REG32(RST_LPD_IOU0, 0x230)
    FIELD(RST_LPD_IOU0, GEM3_RESET, 1, 3)
    FIELD(RST_LPD_IOU0, GEM2_RESET, 1, 2)
    FIELD(RST_LPD_IOU0, GEM1_RESET, 1, 1)
    FIELD(RST_LPD_IOU0, GEM0_RESET, 1, 0)
REG32(RST_LPD_IOU1, 0x234)
REG32(RST_LPD_IOU2, 0x238)
    FIELD(RST_LPD_IOU2, IOU_CC_RESET, 1, 19)
    FIELD(RST_LPD_IOU2, GPIO_RESET, 1, 18)
    FIELD(RST_LPD_IOU2, ADMA_RESET, 1, 17)
    FIELD(RST_LPD_IOU2, NAND_RESET, 1, 16)
    FIELD(RST_LPD_IOU2, SWDT_RESET, 1, 15)
    FIELD(RST_LPD_IOU2, TTC3_RESET, 1, 14)
    FIELD(RST_LPD_IOU2, TTC2_RESET, 1, 13)
    FIELD(RST_LPD_IOU2, TTC1_RESET, 1, 12)
    FIELD(RST_LPD_IOU2, TTC0_RESET, 1, 11)
    FIELD(RST_LPD_IOU2, I2C1_RESET, 1, 10)
    FIELD(RST_LPD_IOU2, I2C0_RESET, 1, 9)
    FIELD(RST_LPD_IOU2, CAN1_RESET, 1, 8)
    FIELD(RST_LPD_IOU2, CAN0_RESET, 1, 7)
    FIELD(RST_LPD_IOU2, SDIO1_RESET, 1, 6)
    FIELD(RST_LPD_IOU2, SDIO0_RESET, 1, 5)
    FIELD(RST_LPD_IOU2, SPI1_RESET, 1, 4)
    FIELD(RST_LPD_IOU2, SPI0_RESET, 1, 3)
    FIELD(RST_LPD_IOU2, UART1_RESET, 1, 2)
    FIELD(RST_LPD_IOU2, UART0_RESET, 1, 1)
    FIELD(RST_LPD_IOU2, QSPI_RESET, 1, 0)
REG32(RST_LPD_TOP, 0x23c)
    FIELD(RST_LPD_TOP, FPD_RESET, 1, 23)
    FIELD(RST_LPD_TOP, SYSMON_RESET, 1, 17)
    FIELD(RST_LPD_TOP, RTC_RESET, 1, 16)
    FIELD(RST_LPD_TOP, APM_RESET, 1, 15)
    FIELD(RST_LPD_TOP, IPI_RESET, 1, 14)
    FIELD(RST_LPD_TOP, USB1_APB_RESET, 1, 11)
    FIELD(RST_LPD_TOP, USB0_APB_RESET, 1, 10)
    FIELD(RST_LPD_TOP, USB1_HIBERRESET, 1, 9)
    FIELD(RST_LPD_TOP, USB0_HIBERRESET, 1, 8)
    FIELD(RST_LPD_TOP, USB1_CORERESET, 1, 7)
    FIELD(RST_LPD_TOP, USB0_CORERESET, 1, 6)
    FIELD(RST_LPD_TOP, RPU_PGE_RESET, 1, 4)
    FIELD(RST_LPD_TOP, RPU_OCM_RESET, 1, 3)
    FIELD(RST_LPD_TOP, RPU_AMBA_RESET, 1, 2)
    FIELD(RST_LPD_TOP, RPU_R51_RESET, 1, 1)
    FIELD(RST_LPD_TOP, RPU_R50_RESET, 1, 0)
REG32(RST_LPD_DBG, 0x240)
    FIELD(RST_LPD_DBG, RPU_DBG1_RESET, 1, 5)
    FIELD(RST_LPD_DBG, RPU_DBG0_RESET, 1, 4)
    FIELD(RST_LPD_DBG, DBG_LPD_RESET, 1, 1)
    FIELD(RST_LPD_DBG, DBG_FPD_RESET, 1, 0)
REG32(BOOT_PIN_CTRL, 0x250)
    FIELD(BOOT_PIN_CTRL, OUT_VAL, 4, 8)
    FIELD(BOOT_PIN_CTRL, IN_VAL, 4, 4)
    FIELD(BOOT_PIN_CTRL, OUT_EN, 4, 0)
REG32(DED_IOB_CTRL0, 0x254)
    FIELD(DED_IOB_CTRL0, DRIVE0, 4, 0)
REG32(DED_IOB_CTRL1, 0x258)
    FIELD(DED_IOB_CTRL1, DRIVE1, 4, 0)
REG32(DED_IOB_CTRL2, 0x25c)
    FIELD(DED_IOB_CTRL2, DRIVE2, 4, 0)
REG32(DED_IOB_CTRL3, 0x260)
    FIELD(DED_IOB_CTRL3, SCHMITT_CMOS_N, 4, 0)
REG32(DED_IOB_CTRL4, 0x264)
    FIELD(DED_IOB_CTRL4, PULL_HIGH_LOW_N, 4, 0)
REG32(DED_IOB_CTRL5, 0x268)
    FIELD(DED_IOB_CTRL5, PULL_ENABLE, 4, 0)
REG32(DED_IOB_CTRL6, 0x26c)
    FIELD(DED_IOB_CTRL6, SLOW_FAST_SLEW_N, 4, 0)

#define R_MAX (R_DED_IOB_CTRL6 + 1)

typedef struct CRL_APB {
    SysBusDevice parent_obj;
    MemoryRegion iomem;
    qemu_irq irq_ir;

    uint32_t regs[R_MAX];
    RegisterInfo regs_info[R_MAX];
} CRL_APB;

static void ir_update_irq(CRL_APB *s)
{
    bool pending = s->regs[R_IR_STATUS] & ~s->regs[R_IR_MASK];
    qemu_set_irq(s->irq_ir, pending);
}

static void ir_status_postw(RegisterInfo *reg, uint64_t val64)
{
    CRL_APB *s = XILINX_CRL_APB(reg->opaque);
    ir_update_irq(s);
}

static uint64_t ir_enable_prew(RegisterInfo *reg, uint64_t val64)
{
    CRL_APB *s = XILINX_CRL_APB(reg->opaque);
    uint32_t val = val64;

    s->regs[R_IR_MASK] &= ~val;
    ir_update_irq(s);
    return 0;
}

static uint64_t ir_disable_prew(RegisterInfo *reg, uint64_t val64)
{
    CRL_APB *s = XILINX_CRL_APB(reg->opaque);
    uint32_t val = val64;

    s->regs[R_IR_MASK] |= val;
    ir_update_irq(s);
    return 0;
}

static RegisterAccessInfo crl_apb_regs_info[] = {
    {   .name = "ERR_CTRL",  .decode.addr = A_ERR_CTRL,
    },{ .name = "IR_STATUS",  .decode.addr = A_IR_STATUS,
        .w1c = 0x1,
        .post_write = ir_status_postw,
    },{ .name = "IR_MASK",  .decode.addr = A_IR_MASK,
        .reset = 0x1,
        .ro = 0x1,
    },{ .name = "IR_ENABLE",  .decode.addr = A_IR_ENABLE,
        .pre_write = ir_enable_prew,
    },{ .name = "IR_DISABLE",  .decode.addr = A_IR_DISABLE,
        .pre_write = ir_disable_prew,
    },{ .name = "CRL_ECO",  .decode.addr = A_CRL_ECO,
    },{ .name = "IOPLL_CTRL",  .decode.addr = A_IOPLL_CTRL,
        .reset = 0x2809,
        .rsvd = 0xf88c80f6L,
    },{ .name = "IOPLL_CFG",  .decode.addr = A_IOPLL_CFG,
        .rsvd = 0x1801210,
    },{ .name = "IOPLL_FRAC_CFG",  .decode.addr = A_IOPLL_FRAC_CFG,
        .rsvd = 0x7e330000,
    },{ .name = "RPLL_CTRL",  .decode.addr = A_RPLL_CTRL,
        .reset = 0x2809,
        .rsvd = 0xf88c80f6L,
    },{ .name = "RPLL_CFG",  .decode.addr = A_RPLL_CFG,
        .rsvd = 0x1801210,
    },{ .name = "RPLL_FRAC_CFG",  .decode.addr = A_RPLL_FRAC_CFG,
        .rsvd = 0x7e330000,
    },{ .name = "PLL_STATUS",  .decode.addr = A_PLL_STATUS,
        .reset = 0x1b,
        .rsvd = 0xffffffc4L,
        .ro = 0x1b,
    },{ .name = "IOPLL_TO_FPD_CTRL",  .decode.addr = A_IOPLL_TO_FPD_CTRL,
        .reset = 0x400,
        .rsvd = 0xc0ff,
    },{ .name = "RPLL_TO_FPD_CTRL",  .decode.addr = A_RPLL_TO_FPD_CTRL,
        .reset = 0x400,
        .rsvd = 0xc0ff,
    },{ .name = "USB3_DUAL_REF_CTRL",  .decode.addr = A_USB3_DUAL_REF_CTRL,
        .reset = 0x52000,
        .rsvd = 0xfdc0c0f8L,
    },{ .name = "GEM0_REF_CTRL",  .decode.addr = A_GEM0_REF_CTRL,
        .reset = 0x2500,
        .rsvd = 0xf9c0c0f8L,
    },{ .name = "GEM1_REF_CTRL",  .decode.addr = A_GEM1_REF_CTRL,
        .reset = 0x2500,
        .rsvd = 0xf9c0c0f8L,
    },{ .name = "GEM2_REF_CTRL",  .decode.addr = A_GEM2_REF_CTRL,
        .reset = 0x2500,
        .rsvd = 0xf9c0c0f8L,
    },{ .name = "GEM3_REF_CTRL",  .decode.addr = A_GEM3_REF_CTRL,
        .reset = 0x2500,
        .rsvd = 0xf9c0c0f8L,
    },{ .name = "USB0_BUS_REF_CTRL",  .decode.addr = A_USB0_BUS_REF_CTRL,
        .reset = 0x52000,
        .rsvd = 0xfdc0c0f8L,
    },{ .name = "USB1_BUS_REF_CTRL",  .decode.addr = A_USB1_BUS_REF_CTRL,
        .reset = 0x12200,
        .rsvd = 0xfdc0c0f8L,
    },{ .name = "QSPI_REF_CTRL",  .decode.addr = A_QSPI_REF_CTRL,
        .reset = 0x1000800,
        .rsvd = 0xfec0c0f8L,
    },{ .name = "SDIO0_REF_CTRL",  .decode.addr = A_SDIO0_REF_CTRL,
        .reset = 0x1003000,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "SDIO1_REF_CTRL",  .decode.addr = A_SDIO1_REF_CTRL,
        .reset = 0x1003f00,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "UART0_REF_CTRL",  .decode.addr = A_UART0_REF_CTRL,
        .reset = 0x1000500,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "UART1_REF_CTRL",  .decode.addr = A_UART1_REF_CTRL,
        .reset = 0x1500,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "SPI0_REF_CTRL",  .decode.addr = A_SPI0_REF_CTRL,
        .reset = 0x1000500,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "SPI1_REF_CTRL",  .decode.addr = A_SPI1_REF_CTRL,
        .reset = 0x1500,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "CAN0_REF_CTRL",  .decode.addr = A_CAN0_REF_CTRL,
        .reset = 0x1000500,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "CAN1_REF_CTRL",  .decode.addr = A_CAN1_REF_CTRL,
        .reset = 0x1500,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "DBG_R5_ATCLK_CTRL",  .decode.addr = A_DBG_R5_ATCLK_CTRL,
        .reset = 0x2500,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "CPU_R5_CTRL",  .decode.addr = A_CPU_R5_CTRL,
        .reset = 0x600,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "OCM_MAIN_CTRL",  .decode.addr = A_OCM_MAIN_CTRL,
        .reset = 0x1500,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "IOU_SWITCH_CTRL",  .decode.addr = A_IOU_SWITCH_CTRL,
        .reset = 0x1500,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "CSU_PLL_CTRL",  .decode.addr = A_CSU_PLL_CTRL,
        .reset = 0x1001504,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "PCAP_CTRL",  .decode.addr = A_PCAP_CTRL,
        .reset = 0x1500,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "LPD_SWITCH_CTRL",  .decode.addr = A_LPD_SWITCH_CTRL,
        .reset = 0x1002000,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "LPD_LSBUS_CTRL",  .decode.addr = A_LPD_LSBUS_CTRL,
        .reset = 0x1002000,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "DBG_LPD_CTRL",  .decode.addr = A_DBG_LPD_CTRL,
        .reset = 0x2000,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "NAND_REF_CTRL",  .decode.addr = A_NAND_REF_CTRL,
        .reset = 0x52000,
        .rsvd = 0xfec0c0f8L,
    },{ .name = "ADMA_REF_CTRL",  .decode.addr = A_ADMA_REF_CTRL,
        .reset = 0x2000,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "PL0_REF_CTRL",  .decode.addr = A_PL0_REF_CTRL,
        .reset = 0x52000,
        .rsvd = 0xfec0c0f8L,
    },{ .name = "PL1_REF_CTRL",  .decode.addr = A_PL1_REF_CTRL,
        .reset = 0x52000,
        .rsvd = 0xfec0c0f8L,
    },{ .name = "PL2_REF_CTRL",  .decode.addr = A_PL2_REF_CTRL,
        .reset = 0x52000,
        .rsvd = 0xfec0c0f8L,
    },{ .name = "PL3_REF_CTRL",  .decode.addr = A_PL3_REF_CTRL,
        .reset = 0x52000,
        .rsvd = 0xfec0c0f8L,
    },{ .name = "PL0_THR_CTRL",  .decode.addr = A_PL0_THR_CTRL,
        .reset = 0x1,
        .rsvd = 0x7ffc,
        .ro = 0xffff8000L,
    },{ .name = "PL0_THR_CNT",  .decode.addr = A_PL0_THR_CNT,
    },{ .name = "PL1_THR_CTRL",  .decode.addr = A_PL1_THR_CTRL,
        .reset = 0x1,
        .rsvd = 0x7ffc,
        .ro = 0xffff8000L,
    },{ .name = "PL1_THR_CNT",  .decode.addr = A_PL1_THR_CNT,
    },{ .name = "PL2_THR_CTRL",  .decode.addr = A_PL2_THR_CTRL,
        .reset = 0x1,
        .rsvd = 0x7ffc,
        .ro = 0xffff8000L,
    },{ .name = "PL2_THR_CNT",  .decode.addr = A_PL2_THR_CNT,
    },{ .name = "PL3_THR_CTRL",  .decode.addr = A_PL3_THR_CTRL,
        .reset = 0x1,
        .rsvd = 0x7ffc,
        .ro = 0xffff8000L,
    },{ .name = "PL3_THR_CNT",  .decode.addr = A_PL3_THR_CNT,
    },{ .name = "GEM_TSU_REF_CTRL",  .decode.addr = A_GEM_TSU_REF_CTRL,
        .reset = 0x51000,
        .rsvd = 0xfec0c0f8L,
    },{ .name = "DLL_REF_CTRL",  .decode.addr = A_DLL_REF_CTRL,
        .rsvd = 0xf8,
    },{ .name = "AMS_REF_CTRL",  .decode.addr = A_AMS_REF_CTRL,
        .reset = 0x1800,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "I2C0_REF_CTRL",  .decode.addr = A_I2C0_REF_CTRL,
        .reset = 0x01000500,
        .rsvd = 0xfec0c0f8L,
    },{ .name = "I2C1_REF_CTRL",  .decode.addr = A_I2C0_REF_CTRL,
        .reset = 0x01000500,
        .rsvd = 0xfec0c0f8L,
    },{ .name = "TIMESTAMP_REF_CTRL",  .decode.addr = A_TIMESTAMP_REF_CTRL,
        .reset = 0x01001800,
        .rsvd = 0xfeffc0f8L,
    },{ .name = "PICDEBUG_TEMP_CTRL",  .decode.addr = A_PICDEBUG_TEMP_CTRL,
        .rsvd = 0xf8,
    },{ .name = "PICDEBUG_REF_CTRL",  .decode.addr = A_PICDEBUG_REF_CTRL,
        .reset = 0x52000,
        .rsvd = 0xfec0c0f8L,
    },{ .name = "PICDEBUG_CTRL",  .decode.addr = A_PICDEBUG_CTRL,
        .rsvd = 0xe0,
    },{ .name = "PICDEBUG_LCNT",  .decode.addr = A_PICDEBUG_LCNT,
    },{ .name = "PICDEBUG_UCNT",  .decode.addr = A_PICDEBUG_UCNT,
        .rsvd = 0xffff0000L,
    },
    {   .name = "BOOT_MODE",  .decode.addr = A_BOOT_MODE,
        .reset = 0x4,
        .rsvd = 0xf0,
    },{ .name = "BOOT_MODE_RAW",  .decode.addr = A_BOOT_MODE_RAW,
        .rsvd = 0xf000,
        .ro = 0xfff,
    },{ .name = "EN_POR_RST",  .decode.addr = A_EN_POR_RST,
        .rsvd = 0xfe0c,
    },{ .name = "MIMIC_RST",  .decode.addr = A_MIMIC_RST,
        .rsvd = 0xfc0c,
    },{ .name = "RESET_CTRL",  .decode.addr = A_RESET_CTRL,
        .reset = 0x40,
        .rsvd = 0xff8c,
        .gpios = (RegisterGPIOMapping[]) {
            { .name = "SRST_B", .bit_pos = 4,   .width = 1 },
            {},
        },
    },{ .name = "BLOCKONLY_RST",  .decode.addr = A_BLOCKONLY_RST,
        .rsvd = 0x7dcc,
        .ro = 0x7dcc,
        .w1c = 0x8233,
    },{ .name = "RESET_REASON",  .decode.addr = A_RESET_REASON,
        .rsvd = 0x7e0c,
        .ro = 0x7e0c,
        .w1c = 0x81f3,
        .reset = 0x1,
    },{ .name = "RST_LPD_IOU0",  .decode.addr = A_RST_LPD_IOU0,
        .reset = 0xf,
        .rsvd = 0xfff0,
    },{ .name = "RST_LPD_IOU1",  .decode.addr = A_RST_LPD_IOU1,
        .rsvd = 0xff,
    },{ .name = "RST_LPD_IOU2",  .decode.addr = A_RST_LPD_IOU2,
        .reset = 0x7ffff,
        .rsvd = 0xfff00000L,
    },{ .name = "RST_LPD_TOP",  .decode.addr = A_RST_LPD_TOP,
        .reset = 0x8fdf,
        .rsvd = 0x7c3020,
        .gpios = (RegisterGPIOMapping[]) {
            { .name = "RST_R5", .bit_pos = 0,   .num = 2 },
            {},
        },
        .inhibit_reset = 1u << 31,
    },{ .name = "RST_LPD_DBG",  .decode.addr = A_RST_LPD_DBG,
        .reset = 0x33,
        .rsvd = 0xffcc,
    },{ .name = "BOOT_PIN_CTRL",  .decode.addr = A_BOOT_PIN_CTRL,
        .rsvd = 0xf000,
        .ro = 0xf0,
    },{ .name = "DED_IOB_CTRL0",  .decode.addr = A_DED_IOB_CTRL0,
        .reset = 0xf,
    },{ .name = "DED_IOB_CTRL1",  .decode.addr = A_DED_IOB_CTRL1,
    },{ .name = "DED_IOB_CTRL2",  .decode.addr = A_DED_IOB_CTRL2,
    },{ .name = "DED_IOB_CTRL3",  .decode.addr = A_DED_IOB_CTRL3,
    },{ .name = "DED_IOB_CTRL4",  .decode.addr = A_DED_IOB_CTRL4,
    },{ .name = "DED_IOB_CTRL5",  .decode.addr = A_DED_IOB_CTRL5,
    },{ .name = "DED_IOB_CTRL6",  .decode.addr = A_DED_IOB_CTRL6,
        .reset = 0xf,
    }
};

static void crl_apb_reset(DeviceState *dev)
{
    CRL_APB *s = XILINX_CRL_APB(dev);
    unsigned int i;

    uint32_t boot_mode = qemu_opt_get_number(qemu_get_boot_opts(),
                                             "mode", 0);
    assert(boot_mode < (1 << R_BOOT_MODE_BOOT_MODE_LENGTH));

    for (i = 0; i < ARRAY_SIZE(s->regs_info); ++i) {
        register_reset(&s->regs_info[i]);
    }

    s->regs[R_BOOT_MODE_RAW] = deposit32(s->regs[R_BOOT_MODE_RAW],
                                         R_BOOT_MODE_BOOT_MODE_SHIFT,
                                         R_BOOT_MODE_BOOT_MODE_LENGTH,
                                         boot_mode);

    s->regs[R_BOOT_MODE] =     deposit32(s->regs[R_BOOT_MODE],
                                         R_BOOT_MODE_BOOT_MODE_SHIFT,
                                         R_BOOT_MODE_BOOT_MODE_LENGTH,
                                         boot_mode);
    ir_update_irq(s);
}

static uint64_t crl_apb_read(void *opaque, hwaddr addr, unsigned size)
{
    CRL_APB *s = XILINX_CRL_APB(opaque);
    RegisterInfo *r = &s->regs_info[addr / 4];

    if (!r->data) {
        qemu_log("%s: Decode error: read from %" HWADDR_PRIx "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr);
        return 0;
    }
    return register_read(r);
}

static void crl_apb_write(void *opaque, hwaddr addr, uint64_t value,
                      unsigned size)
{
    CRL_APB *s = XILINX_CRL_APB(opaque);
    RegisterInfo *r = &s->regs_info[addr / 4];

    if (!r->data) {
        qemu_log("%s: Decode error: read from %" HWADDR_PRIx "=%" PRIx64 "\n",
                 object_get_canonical_path(OBJECT(s)),
                 addr, value);
        return;
    }
    register_write(r, value, ~0);
}

static const MemoryRegionOps crl_apb_ops = {
    .read = crl_apb_read,
    .write = crl_apb_write,
    .endianness = DEVICE_LITTLE_ENDIAN,
    .valid = {
        .min_access_size = 4,
        .max_access_size = 4,
    },
};

static void crl_apb_realize(DeviceState *dev, Error **errp)
{
    CRL_APB *s = XILINX_CRL_APB(dev);
    const char *prefix = object_get_canonical_path(OBJECT(dev));
    unsigned int i;

    for (i = 0; i < ARRAY_SIZE(crl_apb_regs_info); ++i) {
        RegisterInfo *r = &s->regs_info[crl_apb_regs_info[i].decode.addr/4];

        *r = (RegisterInfo) {
            .data = (uint8_t *)&s->regs[
                    crl_apb_regs_info[i].decode.addr/4],
            .data_size = sizeof(uint32_t),
            .access = &crl_apb_regs_info[i],
            .debug = XILINX_CRL_APB_ERR_DEBUG,
            .prefix = prefix,
            .opaque = s,
        };
        register_init(r);
        qdev_pass_all_gpios(DEVICE(r), dev);
    }
}

static void crl_apb_init(Object *obj)
{
    CRL_APB *s = XILINX_CRL_APB(obj);
    SysBusDevice *sbd = SYS_BUS_DEVICE(obj);

    memory_region_init_io(&s->iomem, obj, &crl_apb_ops, s,
                          TYPE_XILINX_CRL_APB, R_MAX * 4);
    sysbus_init_mmio(sbd, &s->iomem);
    sysbus_init_irq(sbd, &s->irq_ir);
}

static const VMStateDescription vmstate_crl_apb = {
    .name = TYPE_XILINX_CRL_APB,
    .version_id = 1,
    .minimum_version_id = 1,
    .minimum_version_id_old = 1,
    .fields = (VMStateField[]) {
        VMSTATE_UINT32_ARRAY(regs, CRL_APB, R_MAX),
        VMSTATE_END_OF_LIST(),
    }
};

static const FDTGenericGPIOSet crl_gpios[] = {
    {
        .names = &fdt_generic_gpio_name_set_gpio,
        .gpios = (FDTGenericGPIOConnection[]) {
            { .name = "RST_R5",     .fdt_index = 0,     .range = 2 },
            { .name = "SRST_B",     .fdt_index = 2  },
            { },
        }
    },
    { },
};

static void crl_apb_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    FDTGenericGPIOClass *fggc = FDT_GENERIC_GPIO_CLASS(klass);

    dc->reset = crl_apb_reset;
    dc->realize = crl_apb_realize;
    dc->vmsd = &vmstate_crl_apb;
    fggc->controller_gpios = crl_gpios;
}

static const TypeInfo crl_apb_info = {
    .name          = TYPE_XILINX_CRL_APB,
    .parent        = TYPE_SYS_BUS_DEVICE,
    .instance_size = sizeof(CRL_APB),
    .class_init    = crl_apb_class_init,
    .instance_init = crl_apb_init,
    .interfaces    = (InterfaceInfo[]) {
        { TYPE_FDT_GENERIC_GPIO },
        { }
    },
};

static void crl_apb_register_types(void)
{
    type_register_static(&crl_apb_info);
}

type_init(crl_apb_register_types)
